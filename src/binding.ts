
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
async greet(name: string) : Promise<string> {
    return await TAURI_INVOKE("greet", { name });
},
/**
 * Retrieve the currently stored access key credential, if any.
 * 
 * This command queries the authentication service for the current
 * `AccessKeyCredential`. It returns `Ok(Some(credential))` when a
 * credential is available, `Ok(None)` when no credential is stored,
 * and `Err(QueryError::Internal(_))` for all other service-level
 * failures. The documentation intentionally omits details about the
 * service's internal error variants.
 * 
 * # Errors
 * 
 * Returns `Err(QueryError::Internal(_))` for unexpected or internal
 * failures from the authentication service.
 * 
 * # Examples
 * 
 * ```rust,ignore
 * // from a Tauri frontend
 * let cred = invoke("current_access_key_credential");
 * ```
 */
async currentAccessKeyCredential() : Promise<Result<AccessKeyCredentials | null, QueryError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("current_access_key_credential") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Validate the provided access key credentials.
 * 
 * This command validates the given `AccessKeyCredentials` by making
 * a request to Aliyun's STS service to retrieve the caller identity.
 * It returns `Ok(CallerIdentityBody)` when the credentials are valid,
 * and `Err(AKValidationError)` when validation fails due to invalid
 * credentials or service errors.
 * 
 * # Errors
 * 
 * Returns `Err(AKValidationError)` when the credentials are invalid
 * or when there are failures communicating with the Aliyun service.
 * 
 * # Examples
 * 
 * ```rust,ignore
 * // from a Tauri frontend
 * let identity = invoke("validate_access_key_credentials", { credentials });
 * ```
 */
async validateAccessKeyCredentials(credentials: AccessKeyCredentials) : Promise<Result<CallerIdentity, AliyunRequestCommandError<AKNotValid>>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("validate_access_key_credentials", { credentials }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Validate and store the provided access key credentials.
 * 
 * This command validates the given `AccessKeyCredentials` and, if valid,
 * stores them in the authentication service for future use. It returns
 * `Ok(CallerIdentityBody)` when the credentials are successfully validated
 * and stored, and `Err(AKFulfillError)` when validation or storage fails.
 * 
 * # Errors
 * 
 * Returns `Err(AKFulfillError)` when the credentials are invalid,
 * when there are failures communicating with the Aliyun service,
 * or when storing the credentials fails.
 * 
 * # Examples
 * 
 * ```rust,ignore
 * // from a Tauri frontend
 * let identity = invoke("fulfill_access_key_credentials", { credentials });
 * ```
 */
async fulfillAccessKeyCredentials(credentials: AccessKeyCredentials) : Promise<Result<CallerIdentity, AliyunRequestCommandError<AKNotValid>>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("fulfill_access_key_credentials", { credentials }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async hasAliyunClient() : Promise<Result<boolean, null>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("has_aliyun_client") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Check if there is a valid Aliyun client available.
 * 
 * This command queries the client service to determine whether a valid
 * Aliyun client instance exists and is properly configured. It returns
 * `Ok(true)` when a valid client is available, `Ok(false)` when no client
 * is configured or the client is invalid, and `Err(ClientValidationError)`
 * for validation failures or service errors.
 * 
 * # Errors
 * 
 * Returns `Err(ClientValidationError)` when there are failures during
 * the validation process or when communicating with the client service.
 * 
 * # Examples
 * 
 * ```rust,ignore
 * // from a Tauri frontend
 * let is_valid = invoke("has_valid_aliyun_client");
 * ```
 */
async hasValidAliyunClient() : Promise<Result<boolean, AliyunRequestCommandError<NoOther>>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("has_valid_aliyun_client") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
}
}

/** user-defined events **/



/** user-defined constants **/



/** user-defined types **/

export type AKNotValid = { type: "AKNotValid"; data: AliyunRejectionTypeShadow }
export type AccessKeyCredentials = { access_key_id: string; access_key_secret: string }
export type AliyunRejectionTypeShadow = { code: string; host_id: string; message: string; request_id: string; recommend: string }
export type AliyunRequestCommandError<E> = { type: "Specific"; error: E } | { type: "RequestFailure"; error: { message: string } } | { type: "InternalError"; error: { message: string } }
export type CallerIdentity = CallerIdentityBodyTypeShadow
export type CallerIdentityBodyTypeShadow = { identity_type: IdentityTypeShadow; request_id: string; account_id: string; principal_id: string; user_id: string; arn: string; role_id: string | null }
export type IdentityTypeShadow = "Account" | "RAMUser" | "AssumedRoleUser"
export type NoOther = null
export type QueryCredentialError = { type: "NotExist" } | { type: "DeserializeError"; error: SerdeJsonError }
export type QueryError = { type: "UnderlyingError"; error: QueryCredentialError }
export type SerdeJsonError = string

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
	Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}
